/*! Minimal marked-compatible parser for offline use. Based on concepts from marked (MIT License). */
(function (global) {
  'use strict';

  function escapeHtml(str) {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function unescapeHtml(str) {
    return str
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'");
  }

  function parseInline(src) {
    if (!src) return '';
    let text = escapeHtml(src);

    text = text.replace(/`([^`]+)`/g, function (_, code) {
      return '<code>' + code.replace(/</g, '&lt;') + '</code>';
    });

    text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    text = text.replace(/__([^_]+)__/g, '<strong>$1</strong>');
    text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
    text = text.replace(/_([^_]+)_/g, '<em>$1</em>');
    text = text.replace(/~~([^~]+)~~/g, '<del>$1</del>');

    text = text.replace(/!\[([^\]]*)\]\(([^\s)]+)(?:\s+"([^"]*)")?\)/g, function (_, alt, href, title) {
      const safeHref = encodeURI(unescapeHtml(href));
      const safeTitle = title ? ' title="' + escapeHtml(title) + '"' : '';
      return '<img src="' + safeHref + '" alt="' + escapeHtml(alt) + '"' + safeTitle + ' />';
    });

    text = text.replace(/\[([^\]]+)\]\(([^\s)]+)(?:\s+"([^"]*)")?\)/g, function (_, label, href, title) {
      const safeHref = encodeURI(unescapeHtml(href));
      const safeTitle = title ? ' title="' + escapeHtml(title) + '"' : '';
      return '<a href="' + safeHref + '"' + safeTitle + '>' + label + '</a>';
    });

    text = text.replace(/(?:https?:\/\/|mailto:)[^\s<]+/g, function (match) {
      const href = encodeURI(unescapeHtml(match));
      return '<a href="' + href + '">' + match + '</a>';
    });

    text = text.replace(/(^|\s)\*\s/g, '$1&ast; ');

    return text;
  }

  function parseTable(lines, start) {
    const headerLine = lines[start];
    const alignLine = lines[start + 1];
    if (!/\|/.test(headerLine) || !/^-{3,}|:-+:?/.test(alignLine.replace(/\s|\|/g, ''))) {
      return null;
    }

    const headers = headerLine.split('|').map(function (cell) {
      return cell.trim();
    });
    const aligns = alignLine.split('|').map(function (cell) {
      const trimmed = cell.trim();
      if (/^:-+:$/.test(trimmed)) return 'center';
      if (/^:-+$/.test(trimmed)) return 'left';
      if (/^-+:$/.test(trimmed)) return 'right';
      return null;
    });

    let bodyRows = [];
    let idx = start + 2;
    while (idx < lines.length && /\|/.test(lines[idx])) {
      bodyRows.push(lines[idx]);
      idx += 1;
    }

    if (!bodyRows.length) {
      return null;
    }

    const thead = '<thead><tr>' + headers.map(function (cell, i) {
      const align = aligns[i] ? ' align="' + aligns[i] + '"' : '';
      return '<th' + align + '>' + parseInline(cell) + '</th>';
    }).join('') + '</tr></thead>';

    const tbody = '<tbody>' + bodyRows.map(function (row) {
      const cells = row.split('|').map(function (cell) {
        return cell.trim();
      });
      return '<tr>' + cells.map(function (cell, i) {
        const align = aligns[i] ? ' align="' + aligns[i] + '"' : '';
        return '<td' + align + '>' + parseInline(cell) + '</td>';
      }).join('') + '</tr>';
    }).join('') + '</tbody>';

    return {
      html: '<table>' + thead + tbody + '</table>',
      end: idx
    };
  }

  function parseList(lines, start) {
    const first = lines[start];
    const ordered = /^\s*\d+\./.test(first);
    const markerPattern = ordered ? /^(\s*)(\d+\.)(\s*)(.*)$/ : /^(\s*)([*+-])(\s+)(.*)$/;
    const tag = ordered ? 'ol' : 'ul';
    let html = '<' + tag + '>';
    let idx = start;
    let currentIndent = null;

    while (idx < lines.length) {
      const line = lines[idx];
      if (!markerPattern.test(line)) {
        break;
      }
      const match = markerPattern.exec(line);
      const indent = match[1].length;
      if (currentIndent === null) {
        currentIndent = indent;
      }
      if (indent > currentIndent) {
        break;
      }
      let content = match[4];
      idx += 1;
      const buffer = [content];
      while (idx < lines.length && lines[idx].trim() !== '' && !markerPattern.test(lines[idx])) {
        buffer.push(lines[idx].trim());
        idx += 1;
      }
      const inner = parseBlocks(buffer.join('\n'));
      html += '<li>' + inner + '</li>';
      while (idx < lines.length && lines[idx].trim() === '') {
        idx += 1;
      }
    }

    html += '</' + tag + '>';
    return { html: html, end: idx };
  }

  function parseBlocks(markdown) {
    const src = markdown.replace(/\r\n?|\r/g, '\n');
    const lines = src.split('\n');
    let idx = 0;
    let html = '';
    let paragraph = [];

    function flushParagraph() {
      if (!paragraph.length) return;
      html += '<p>' + parseInline(paragraph.join(' ')) + '</p>';
      paragraph = [];
    }

    while (idx < lines.length) {
      const line = lines[idx];
      if (!line.trim()) {
        flushParagraph();
        idx += 1;
        continue;
      }

      const headingMatch = line.match(/^ {0,3}(#{1,6})\s+(.*)$/);
      if (headingMatch) {
        flushParagraph();
        const level = headingMatch[1].length;
        html += '<h' + level + '>' + parseInline(headingMatch[2].trim()) + '</h' + level + '>';
        idx += 1;
        continue;
      }

      if (/^ {0,3}(?:\*{3,}|-{3,}|_{3,})\s*$/.test(line)) {
        flushParagraph();
        html += '<hr />';
        idx += 1;
        continue;
      }

      const fenceMatch = line.match(/^ {0,3}(`{3,}|~{3,})(.*)$/);
      if (fenceMatch) {
        flushParagraph();
        const fence = fenceMatch[1];
        const lang = fenceMatch[2].trim().split(/\s+/)[0] || '';
        idx += 1;
        const buffer = [];
        while (idx < lines.length && !new RegExp('^ {0,3}' + fence + '\\s*$').test(lines[idx])) {
          buffer.push(lines[idx]);
          idx += 1;
        }
        if (idx < lines.length) {
          idx += 1;
        }
        const code = escapeHtml(buffer.join('\n'));
        const className = lang ? ' class="language-' + lang.replace(/[^\w-]/g, '') + '"' : '';
        html += '<pre><code' + className + '>' + code + '</code></pre>';
        continue;
      }

      if (/^>/.test(line)) {
        flushParagraph();
        const buffer = [];
        while (idx < lines.length && /^>/.test(lines[idx])) {
          buffer.push(lines[idx].replace(/^> ?/, ''));
          idx += 1;
        }
        html += '<blockquote>' + parseBlocks(buffer.join('\n')) + '</blockquote>';
        continue;
      }

      const table = parseTable(lines, idx);
      if (table) {
        flushParagraph();
        html += table.html;
        idx = table.end;
        continue;
      }

      if (/^\s*([*+-]|\d+\.)\s+/.test(line)) {
        flushParagraph();
        const listResult = parseList(lines, idx);
        html += listResult.html;
        idx = listResult.end;
        continue;
      }

      const indentedCode = line.match(/^( {4,})(.*)$/);
      if (indentedCode) {
        flushParagraph();
        const buffer = [indentedCode[2]];
        idx += 1;
        while (idx < lines.length && /^( {4,})(.*)$/.test(lines[idx])) {
          buffer.push(RegExp.$2);
          idx += 1;
        }
        html += '<pre><code>' + escapeHtml(buffer.join('\n')) + '</code></pre>';
        continue;
      }

      paragraph.push(line.trim());
      idx += 1;
    }

    flushParagraph();
    return html;
  }

  function marked(src) {
    return parseBlocks(src || '');
  }

  marked.parse = marked;

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = marked;
  } else {
    global.marked = marked;
  }
})(typeof window !== 'undefined' ? window : globalThis);
